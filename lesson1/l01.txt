## 什么是分布式系统?

* 多计算机协作
* DNS,P2P的文件共享
* 大型数据 MapReduce，以及很多的关键性基础架构都是分布式的。

## 为什么要分布式?

* 去连接物理上分离的实体
* 去通过隔离获得安全性
* 去通过复制来容错
* 去通过并行的CPU/mem/disk/net来达到横向扩展

但是这很复杂， 许多并发的组件，必须处理好部分组件失败的情况，也 很难去了解性能的瓶颈


## MAIN TOPICS

关于抽象，就是隐藏了分布式应用程序的复杂性，有三大类抽象:

* 存储
* 通信
* 计算

关于分布式有一堆topic被反复探究。

## 实现


1. RPC
2. 线程
3. 并发控制


## 性能

期望得到可伸缩的吞吐量，N台 服务器通过并行的CPU,磁盘,网络提高N倍吞吐量，因此处理更高的负载只需要买更多的计算机，但是实际上扩展会变得越来越难，如何负载均衡，如何隐藏共享资源，如何处理无法并行处理的部分。

## 容错

1000台服务器，复杂的网络 总是会出现某些服务挂掉了，我们希望在应用程序程序隐藏这些失败的情况
我们通常希望用下面两个来度量:

* 可用性 -- 我可以一直使用我的文件无论是否失败
* 持久性 -- 当故障被修复了，我的文件可以继续使用

> 容错的思路：
> 通过副本服务器来解决，如果一个服务器crash了，客户可以使用其他的服务器。

## 一致性

基本目的是基础设施需要一个明确的行为，比如: Get(k)得到的结果是来自于最近一次的put(k,v)，完成良好的行为是很难的!

* Clients提交并发操作
* Servers crash在不恰当的时刻
* 网络可能会让存活的服务器看起来是死的，产生脑裂的现象

都会导致数据和状态的不一致性，一致性和性能是敌人，过于强调严格的一致性会导致系统很慢，快速的系统通常会让应用程序处理复杂的弱一致性行为。

> 人们试图会在这里去寻求设计上的平衡。

## 案列研究: MapReduce

### MapReduce 概述

总体目标: 不需要专家级别的程序员就可以简单并且高效合理的解决巨大的数据处理的问题。

​ 程序员只需要定义一个Map和一个Reduce函数即可，都是顺序执行的代码；通常是相当的简单。MR将程序员编写的函数运行在1000s台主机，并输入一个巨大的数据集，并屏蔽底层所有的分布式相关的细节

### MapReduce的抽象视图

```
Input Map -> a,1  b,1 c,1
Input Map ->      b,1
Input Map -> a,1      c,1
              |    |   |
                   |   -> Reduce -> c,2
                   -----> Reduce -> b,2
```

Map 阶段产生了中间数据，Reduce阶段收集这些中间数据进行处理最终输出结果。

例子: 单词统计
输入上千个文件
  Map(k, v)

```python
split v into words
for each word w
  emit(w, "1")
```
  Reduce(k, v)
```python
emit(len(v))
```

这个模型很容易去编程，它隐藏了很多令人不快的细节:

* 并发
* 数据移动
* 错误处理
* 在服务器上启动worker来处理任务

这个模型扩展性很好:

N倍的计算机可以让Map()和Reduce()产生N倍的吞吐量，因为这两个阶段都可以并行，他们之间不存在数据竞争和顺序关系，通过购买更多的计算机可以得到更高的吞吐量，计算机远远要比程序员便宜。

1. 什么因素会影响集群的性能?
2. MapReduce如何进行容错?
3. 如何提升网络性能?
4. 如何做好负载均衡?

参见[ MapReduce论文笔记](http://blog.csdn.net/zhangyifei216/article/details/53231054)

### 总结

- 不是最高效和灵活的
+ 扩展性很好
+ 易于编程，隐藏了底层的数据移动和错误

### 参考文献
* [mapreduce](https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf)
* [MIT 分布式系统课程讲义1](https://pdos.csail.mit.edu/6.824/notes/l01.txt)
